{"ast":null,"code":"var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Preventive platform detection\n// istanbul ignore next\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== \"undefined\";\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\n  }\n})();\n\n// Whether to use the native URL object or the legacy url module\nvar useNativeURL = false;\ntry {\n  assert(new URL(\"\"));\n} catch (error) {\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\n}\n\n// URL fields to preserve in copy operations\nvar preservedUrlFields = [\"auth\", \"host\", \"hostname\", \"href\", \"path\", \"pathname\", \"port\", \"protocol\", \"query\", \"search\", \"hash\"];\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar InvalidUrlError = createErrorType(\"ERR_INVALID_URL\", \"Invalid URL\", TypeError);\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\", RedirectionError);\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\n\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    } catch (cause) {\n      self.emit(\"error\", cause instanceof RedirectionError ? cause : new RedirectionError({\n        cause: cause\n      }));\n    }\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n  this._currentRequest.abort();\n  this.emit(\"abort\");\n};\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  } else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  } else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    self.removeListener(\"close\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  } else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  this.on(\"close\", clearTimer);\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n});\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    throw new TypeError(\"Unsupported protocol \" + protocol);\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request and set up its event handlers\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  }\n\n  // RFC7230ยง5.3.1: When making a request directly to an origin server, [โฆ]\n  // a client MUST send only the absolute path [โฆ] as the request-target.\n  this._currentUrl = /^\\//.test(this._options.path) ? url.format(this._options) :\n  // When making a request to a proxy, [โฆ]\n  // a client MUST send the target URI in absolute-form [โฆ].\n  this._options.path;\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          // istanbul ignore else\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    })();\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode\n    });\n  }\n\n  // RFC7231ยง6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  destroyRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC7231ยง6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  }\n\n  // Store the request headers if applicable\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\")\n    }, this._options.headers);\n  }\n\n  // RFC7231ยง6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, [โฆ]\n  // RFC7231ยง6.4.2โ3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  var method = this._options.method;\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n  // RFC7231ยง6.4.4: The 303 (See Other) status code indicates that\n  // the server is redirecting the user agent to a different resource [โฆ]\n  // A user agent can perform a retrieval request targeting that URI\n  // (a GET or HEAD request if using HTTP) [โฆ]\n  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n    host: currentHost\n  }));\n\n  // Create the redirected request\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug(\"redirecting to\", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== \"https:\" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  this._performRequest();\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      } else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      } else {\n        callback = options;\n        options = validateUrl(input);\n        input = {\n          protocol: protocol\n        };\n      }\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = \"::1\";\n      }\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: {\n        value: request,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      },\n      get: {\n        value: get,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }\n    });\n  });\n  return exports;\n}\nfunction noop() {/* empty */}\nfunction parseUrl(input) {\n  var parsed;\n  // istanbul ignore else\n  if (useNativeURL) {\n    parsed = new URL(input);\n  } else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({\n        input\n      });\n    }\n  }\n  return parsed;\n}\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({\n      input: input.href || input\n    });\n  }\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({\n      input: input.href || input\n    });\n  }\n  return input;\n}\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  }\n\n  // Fix IPv6 hostname\n  if (spread.hostname.startsWith(\"[\")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  }\n  // Ensure port is a number\n  if (spread.port !== \"\") {\n    spread.port = Number(spread.port);\n  }\n  // Concatenate path\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n  return spread;\n}\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\n  }\n\n  // Attach constructor and set default properties\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false\n    },\n    name: {\n      value: \"Error [\" + code + \"]\",\n      enumerable: false\n    }\n  });\n  return CustomError;\n}\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n  request.on(\"error\", noop);\n  request.destroy(error);\n}\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\nfunction isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isBuffer(value) {\n  return typeof value === \"object\" && \"length\" in value;\n}\nfunction isURL(value) {\n  return URL && value instanceof URL;\n}\n\n// Exports\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"names":["url","require","URL","http","https","Writable","assert","debug","detectUnsupportedEnvironment","looksLikeNode","process","looksLikeBrowser","window","document","looksLikeV8","isFunction","Error","captureStackTrace","console","warn","useNativeURL","error","code","preservedUrlFields","events","eventHandlers","Object","create","forEach","event","arg1","arg2","arg3","_redirectable","emit","InvalidUrlError","createErrorType","TypeError","RedirectionError","TooManyRedirectsError","MaxBodyLengthExceededError","WriteAfterEndError","destroy","prototype","noop","RedirectableRequest","options","responseCallback","call","_sanitizeOptions","_options","_ended","_ending","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","on","self","_onNativeResponse","response","_processResponse","cause","_performRequest","abort","destroyRequest","_currentRequest","write","data","encoding","callback","isString","isBuffer","length","maxBodyLength","push","end","currentRequest","setHeader","name","value","headers","removeHeader","setTimeout","msecs","destroyOnTimeout","socket","removeListener","addListener","startTimer","_timeout","clearTimeout","clearTimer","once","method","a","b","property","defineProperty","get","host","hostname","pathname","path","searchPos","indexOf","substring","search","protocol","nativeProtocol","nativeProtocols","agents","scheme","slice","agent","request","_currentUrl","test","format","_isRedirect","i","buffers","writeNext","buffer","finished","statusCode","trackRedirects","location","followRedirects","responseUrl","redirects","maxRedirects","requestHeaders","beforeRedirect","assign","Host","req","getHeader","removeMatchingHeaders","currentHostHeader","currentUrlParts","parseUrl","currentHost","currentUrl","redirectUrl","resolveUrl","href","spreadUrlObject","isSubdomain","responseDetails","requestDetails","wrap","protocols","exports","keys","wrappedProtocol","input","isURL","validateUrl","equal","wrappedRequest","defineProperties","configurable","enumerable","writable","parsed","parse","relative","base","resolve","urlObject","target","spread","key","startsWith","port","Number","regex","lastValue","header","undefined","String","trim","message","baseClass","CustomError","properties","constructor","subdomain","domain","dot","endsWith","module"],"sources":["/Users/zeta/Documents/years_web/node_modules/follow-redirects/index.js"],"sourcesContent":["var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Preventive platform detection\n// istanbul ignore next\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== \"undefined\";\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\n  }\n}());\n\n// Whether to use the native URL object or the legacy url module\nvar useNativeURL = false;\ntry {\n  assert(new URL(\"\"));\n}\ncatch (error) {\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\n}\n\n// URL fields to preserve in copy operations\nvar preservedUrlFields = [\n  \"auth\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"path\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"query\",\n  \"search\",\n  \"hash\",\n];\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar InvalidUrlError = createErrorType(\n  \"ERR_INVALID_URL\",\n  \"Invalid URL\",\n  TypeError\n);\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\",\n  RedirectionError\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    }\n    catch (cause) {\n      self.emit(\"error\", cause instanceof RedirectionError ?\n        cause : new RedirectionError({ cause: cause }));\n    }\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n  this._currentRequest.abort();\n  this.emit(\"abort\");\n};\n\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    self.removeListener(\"close\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  this.on(\"close\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    throw new TypeError(\"Unsupported protocol \" + protocol);\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request and set up its event handlers\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  }\n\n  // RFC7230ยง5.3.1: When making a request directly to an origin server, [โฆ]\n  // a client MUST send only the absolute path [โฆ] as the request-target.\n  this._currentUrl = /^\\//.test(this._options.path) ?\n    url.format(this._options) :\n    // When making a request to a proxy, [โฆ]\n    // a client MUST send the target URI in absolute-form [โฆ].\n    this._options.path;\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          // istanbul ignore else\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231ยง6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false ||\n      statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  destroyRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC7231ยง6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  }\n\n  // Store the request headers if applicable\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\"),\n    }, this._options.headers);\n  }\n\n  // RFC7231ยง6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, [โฆ]\n  // RFC7231ยง6.4.2โ3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  var method = this._options.method;\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n      // RFC7231ยง6.4.4: The 303 (See Other) status code indicates that\n      // the server is redirecting the user agent to a different resource [โฆ]\n      // A user agent can perform a retrieval request targeting that URI\n      // (a GET or HEAD request if using HTTP) [โฆ]\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n  // Create the redirected request\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug(\"redirecting to\", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\n     redirectUrl.protocol !== \"https:\" ||\n     redirectUrl.host !== currentHost &&\n     !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode,\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders,\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  this._performRequest();\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      }\n      else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      }\n      else {\n        callback = options;\n        options = validateUrl(input);\n        input = { protocol: protocol };\n      }\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = \"::1\";\n      }\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\nfunction noop() { /* empty */ }\n\nfunction parseUrl(input) {\n  var parsed;\n  // istanbul ignore else\n  if (useNativeURL) {\n    parsed = new URL(input);\n  }\n  else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({ input });\n    }\n  }\n  return parsed;\n}\n\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\n\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  return input;\n}\n\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  }\n\n  // Fix IPv6 hostname\n  if (spread.hostname.startsWith(\"[\")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  }\n  // Ensure port is a number\n  if (spread.port !== \"\") {\n    spread.port = Number(spread.port);\n  }\n  // Concatenate path\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n\n  return spread;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\n  }\n\n  // Attach constructor and set default properties\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false,\n    },\n    name: {\n      value: \"Error [\" + code + \"]\",\n      enumerable: false,\n    },\n  });\n  return CustomError;\n}\n\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n  request.on(\"error\", noop);\n  request.destroy(error);\n}\n\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n}\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isBuffer(value) {\n  return typeof value === \"object\" && (\"length\" in value);\n}\n\nfunction isURL(value) {\n  return URL && value instanceof URL;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}